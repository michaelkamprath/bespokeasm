import sys
from typing import Literal

from bespokeasm.assembler.model.instruction_base import InstructionBase
from bespokeasm.assembler.model.operand_parser import OperandParser
from bespokeasm.assembler.model.operand_set import OperandSetCollection

# Instruction
#
# An instruction has two parts: mnemonic and zero or more operands. The instruction
# will generate machine code that consists first of the byte code from the mnemonic
# then each of the operands (in order), and then followed by the data generated by each
# in order.
#
# InstructionVariant
#
# An instruction variant is a configuration associated with a specific base byte code
# from the mnemonic.
#


class InstructionVariant(InstructionBase):
    def __init__(
                self,
                mnemonic: str,
                instruction_variant_config: dict,
                operand_set_collection: OperandSetCollection,
                default_multi_word_endian: Literal['big', 'little'],
                default_intra_word_endian: Literal['big', 'little'],
                registers: set[str],
                variant_num: int,
                word_size: int,
                word_segment_size: int,
            ) -> None:
        super().__init__(mnemonic, default_multi_word_endian, default_intra_word_endian, registers)
        self._variant_config = instruction_variant_config
        # validate config
        if 'bytecode' not in self._variant_config:
            if variant_num == 0:
                sys.exit(f'ERROR: configuration for instruction "{mnemonic}" does not have a byte code configuration')
            else:
                sys.exit(
                    f'ERROR: configuration for instruction "{mnemonic}" does not have a '
                    f'byte code configuration in variant {variant_num}.'
                )
        if 'operands' in self._variant_config:
            try:
                self._operand_parser = OperandParser(
                    mnemonic,
                    self._variant_config.get('operands', None),
                    operand_set_collection,
                    default_multi_word_endian,
                    default_intra_word_endian,
                    registers,
                    word_size,
                    word_segment_size,
                )
            except TypeError as e:
                sys.exit(f'ERROR: Operand configuration for instruction "{mnemonic}" is invalid: {e}')
            self._operand_parser.validate(mnemonic)
        else:
            self._operand_parser = None

    @property
    def operand_count(self) -> int:
        return self._operand_parser.operand_count

    @property
    def base_bytecode_size(self) -> int:
        if 'size' not in self._variant_config['bytecode']:
            sys.exit(f'ERROR: Instruction "{self.mnemonic}" does not have a bytecode size configured')
        return self._variant_config['bytecode']['size']

    @property
    def base_bytecode_value(self) -> int:
        if 'value' not in self._variant_config['bytecode']:
            sys.exit(f'ERROR: Instruction "{self.mnemonic}" does not have a bytecode value configured')
        return self._variant_config['bytecode']['value']

    @property
    def has_bytecode_suffix(self) -> bool:
        return 'suffix' in self._variant_config['bytecode']

    @property
    def suffix_bytecode_size(self) -> int:
        if self.has_bytecode_suffix:
            return self._variant_config['bytecode']['suffix']['size']
        else:
            return 0

    @property
    def suffix_bytecode_value(self) -> int:
        if self.has_bytecode_suffix:
            return self._variant_config['bytecode']['suffix']['value']
        else:
            return 0

    def __str__(self) -> str:
        operand_str = str(self._operand_parser) if self._operand_parser is not None else 'NO_OPERANDS'
        return f'InstructionVariant<{self._mnemonic, operand_str}>'


class Instruction(InstructionBase):
    def __init__(
                self,
                mnemonic: str,
                instruction_config: dict,
                operand_set_collection: OperandSetCollection,
                default_multi_word_endian: Literal['big', 'little'],
                default_intra_word_endian: Literal['big', 'little'],
                registers: set[str],
                word_size: int,
                word_segment_size: int,
            ) -> None:
        super().__init__(mnemonic, default_multi_word_endian, default_intra_word_endian, registers)
        self._config = instruction_config

        variant_num = 0
        self._variants: list[InstructionVariant] = []
        if 'bytecode' in instruction_config:
            self._variants.append(
                InstructionVariant(
                    mnemonic,
                    instruction_config,
                    operand_set_collection,
                    default_multi_word_endian,
                    default_intra_word_endian,
                    registers,
                    variant_num,
                    word_size,
                    word_segment_size,
                )
            )

        if 'variants' in self._config:
            for variant_config in self._config['variants']:
                variant_num += 1
                self._variants.append(
                    InstructionVariant(
                        mnemonic,
                        variant_config,
                        operand_set_collection,
                        default_multi_word_endian,
                        default_intra_word_endian,
                        registers,
                        variant_num,
                        word_size,
                        word_segment_size,
                    )
                )
        if len(self._variants) == 0:
            sys.exit(f'ERROR - Configuration for instruction "{mnemonic}" has no valid variant.')

    @property
    def variants(self) -> list[InstructionVariant]:
        return self._variants

    def __str__(self) -> str:
        return f'Instruction<{self._mnemonic}>'
