import re
import sys

from bespokeasm.assembler.model import AssemblerModel
from bespokeasm.assembler.line_identifier import LineIdentifier
from bespokeasm.assembler.line_object import LineObject, INSTRUCTION_EXPRESSION_PATTERN
from bespokeasm.assembler.line_object.data_line import DataLine
from bespokeasm.assembler.memory_zone.manager import MemoryZoneManager
from bespokeasm.assembler.memory_zone import MEMORY_ZONE_NAME_PATTERN, MemoryZone

from .address import AddressOrgLine
from .memzone import SetMemoryZoneLine
from .fill_data import FillDataLine, FillUntilDataLine
from .page_align import PageAlignLine

# Directives are lines that tell the assembler to do something with respect to current address or
# generated byte code. Supported directives are:
#
#   .org X          - (re)sets the current address to X but does not pad. Shou;d be used at top of code.
#   .byte X         - Emits byte or set of bytes
#   .fill X, Y      - Fills X bytes from curent address with (Y&0xFF)
#   .zero X         - shorthand for ".fill X, 0"
#   .zerountil X    - fill with 0 value until and including address X
#   .memzone X      - sets the current memory zone to X
#   .page [X]       - aligns the current address to the next page boundary


class DirectiveLine:

    PATTERN_ORG_DIRECTIVE = re.compile(
        r'^(?:\.org)\s+({})(?:\s*\"({})\")?'.format(
            INSTRUCTION_EXPRESSION_PATTERN,
            MEMORY_ZONE_NAME_PATTERN,
        ),
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_SET_MEMZONE_DIRECTIVE = re.compile(
        r'^(?:\.memzone)\s+({})'.format(MEMORY_ZONE_NAME_PATTERN),
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_FILL_DIRECTIVE = re.compile(
        r'^(?:\.fill)\s+({})\s*\,\s*({})'.format(
            INSTRUCTION_EXPRESSION_PATTERN, INSTRUCTION_EXPRESSION_PATTERN
        ),
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_ZERO_DIRECTIVE = re.compile(
        r'^(?:\.zero)\s+({})'.format(INSTRUCTION_EXPRESSION_PATTERN),
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_ZEROUNTIL_DIRECTIVE = re.compile(
        r'^(?:\.zerountil)\s+({})'.format(INSTRUCTION_EXPRESSION_PATTERN),
        flags=re.IGNORECASE | re.MULTILINE
    )

    def factory(
        line_id: LineIdentifier,
        line_str: str,
        comment: str,
        endian: str,
        current_memzone: MemoryZone,
        memzone_manager: MemoryZoneManager,
        isa_model: AssemblerModel,
    ) -> LineObject:
        # for efficiency, if it doesn't start with a period, it is not a directive
        cleaned_line_str = line_str.strip()
        if not cleaned_line_str.startswith('.'):
            return None
        # first, the .org
        line_match = re.search(DirectiveLine.PATTERN_ORG_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) >= 1:
            value_str = line_match.group(1)
            memzone_name = line_match.group(2)
            return AddressOrgLine(line_id, line_match.group(0), comment, value_str, memzone_name, memzone_manager)

        # .memzone
        line_match = re.search(DirectiveLine.PATTERN_SET_MEMZONE_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 1:
            name_str = line_match.group(1)
            return SetMemoryZoneLine(line_id, line_match.group(0), comment, name_str, memzone_manager)

        # .fill
        line_match = re.search(DirectiveLine.PATTERN_FILL_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 2:
            count_str = line_match.group(1)
            value_str = line_match.group(2)
            return FillDataLine(
                line_id,
                line_match.group(0),
                comment,
                count_str,
                value_str,
                current_memzone,
            )

        # .zero
        line_match = re.search(DirectiveLine.PATTERN_ZERO_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 1:
            count_str = line_match.group(1)
            if len(count_str) == 0:
                sys.exit(f'ERROR: {line_id} - .zero directive missing length argument')
            return FillDataLine(
                line_id,
                line_match.group(0),
                comment,
                count_str,
                '0',
                current_memzone,
            )

        # .zerountil
        line_match = re.search(DirectiveLine.PATTERN_ZEROUNTIL_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 1:
            address_str = line_match.group(1)
            return FillUntilDataLine(
                line_id,
                line_match.group(0),
                comment,
                address_str,
                '0',
                current_memzone,
            )

        # .page
        line_match = PageAlignLine.PATTERN_PAGE_ALIGN.match(cleaned_line_str)
        if line_match is not None:
            return PageAlignLine(line_id, cleaned_line_str, comment, current_memzone, isa_model.page_size)

        # nothing was matched here. pass to data directive
        return DataLine.factory(line_id, line_str, comment, endian, current_memzone, isa_model.cstr_terminator)
