import re
import sys

from bespokeasm.assembler.line_identifier import LineIdentifier
from bespokeasm.assembler.line_object import INSTRUCTION_EXPRESSION_PATTERN
from bespokeasm.assembler.line_object import LineObject
from bespokeasm.assembler.line_object.data_line import DataLine
from bespokeasm.assembler.memory_zone import MEMORY_ZONE_NAME_PATTERN
from bespokeasm.assembler.memory_zone import MemoryZone
from bespokeasm.assembler.memory_zone.manager import MemoryZoneManager
from bespokeasm.assembler.model import AssemblerModel

from .address import AddressOrgLine
from .fill_data import FillDataLine
from .fill_data import FillUntilDataLine
from .memzone import SetMemoryZoneLine
from .page_align import PageAlignLine

# Directives are lines that tell the assembler to do something with respect to current address or
# generated byte code. Supported directives are:
#
#   .org X          - (re)sets the current address to X but does not pad. Shou;d be used at top of code.
#   .byte X         - Emits byte or set of bytes
#   .fill X, Y      - Fills X bytes from curent address with (Y&0xFF)
#   .zero X         - shorthand for ".fill X, 0"
#   .zerountil X    - fill with 0 value until and including address X
#   .memzone X      - sets the current memory zone to X
#   .align [X]      - aligns the current address to the next page boundary


class DirectiveLine:

    PATTERN_ORG_DIRECTIVE = re.compile(
        r'^(?:\.org)\s+({})(?:\s*\"({})\")?'.format(
            INSTRUCTION_EXPRESSION_PATTERN,
            MEMORY_ZONE_NAME_PATTERN,
        ),
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_SET_MEMZONE_DIRECTIVE = re.compile(
        fr'^(?:\.memzone)\s+({MEMORY_ZONE_NAME_PATTERN})',
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_FILL_DIRECTIVE = re.compile(
        r'^(?:\.fill)\s+({})\s*\,\s*({})'.format(
            INSTRUCTION_EXPRESSION_PATTERN, INSTRUCTION_EXPRESSION_PATTERN
        ),
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_ZERO_DIRECTIVE = re.compile(
        fr'^(?:\.zero)\s+({INSTRUCTION_EXPRESSION_PATTERN})',
        flags=re.IGNORECASE | re.MULTILINE
    )

    PATTERN_ZEROUNTIL_DIRECTIVE = re.compile(
        fr'^(?:\.zerountil)\s+({INSTRUCTION_EXPRESSION_PATTERN})',
        flags=re.IGNORECASE | re.MULTILINE
    )

    def factory(
        line_id: LineIdentifier,
        line_str: str,
        comment: str,
        current_memzone: MemoryZone,
        memzone_manager: MemoryZoneManager,
        isa_model: AssemblerModel,
    ) -> LineObject | None:
        # for efficiency, if it doesn't start with a period, it is not a directive
        cleaned_line_str = line_str.strip()
        if not cleaned_line_str.startswith('.'):
            return None
        # first, the .org
        line_match = re.search(DirectiveLine.PATTERN_ORG_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) >= 1:
            value_str = line_match.group(1)
            memzone_name = line_match.group(2)
            return AddressOrgLine(line_id, line_match.group(0), comment, value_str, memzone_name, memzone_manager)

        # .memzone
        line_match = re.search(DirectiveLine.PATTERN_SET_MEMZONE_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 1:
            name_str = line_match.group(1)
            return SetMemoryZoneLine(line_id, line_match.group(0), comment, name_str, memzone_manager)

        # .fill
        line_match = re.search(DirectiveLine.PATTERN_FILL_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 2:
            count_str = line_match.group(1)
            value_str = line_match.group(2)
            return FillDataLine(
                line_id,
                line_match.group(0),
                comment,
                count_str,
                value_str,
                current_memzone,
                isa_model.word_size,
                isa_model.word_segment_size,
                isa_model.intra_word_endianness,
                isa_model.multi_word_endianness,
            )

        # .zero
        line_match = re.search(DirectiveLine.PATTERN_ZERO_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 1:
            count_str = line_match.group(1)
            if len(count_str) == 0:
                sys.exit(f'ERROR: {line_id} - .zero directive missing length argument')
            return FillDataLine(
                line_id,
                line_match.group(0),
                comment,
                count_str,
                '0',
                current_memzone,
                isa_model.word_size,
                isa_model.word_segment_size,
                isa_model.intra_word_endianness,
                isa_model.multi_word_endianness,
            )

        # .zerountil
        line_match = re.search(DirectiveLine.PATTERN_ZEROUNTIL_DIRECTIVE, cleaned_line_str)
        if line_match is not None and len(line_match.groups()) == 1:
            address_str = line_match.group(1)
            return FillUntilDataLine(
                line_id,
                line_match.group(0),
                comment,
                address_str,
                '0',
                current_memzone,
                isa_model.word_size,
                isa_model.word_segment_size,
                isa_model.intra_word_endianness,
                isa_model.multi_word_endianness,
            )

        # .page
        line_match = PageAlignLine.PATTERN_PAGE_ALIGN.match(cleaned_line_str)
        if line_match is not None:
            return PageAlignLine(line_id, cleaned_line_str, comment, current_memzone, isa_model.page_size)

        # nothing was matched here. pass to data directive
        return DataLine.factory(
            line_id,
            line_str,
            comment,
            current_memzone,
            isa_model.word_size,
            isa_model.word_segment_size,
            isa_model.intra_word_endianness,
            isa_model.multi_word_endianness,
            isa_model.cstr_terminator,
            isa_model.string_byte_packing,
            isa_model.string_byte_packing_fill,
            diagnostic_reporter=isa_model.diagnostic_reporter)
