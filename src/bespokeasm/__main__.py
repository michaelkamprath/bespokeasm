import click
import os
import sys

import yaml
from bespokeasm import BESPOKEASM_VERSION_STR
from bespokeasm.assembler.engine import Assembler
from bespokeasm.assembler.model import AssemblerModel
from bespokeasm.configgen.vscode import VSCodeConfigGenerator
from bespokeasm.configgen.sublime import SublimeConfigGenerator


@click.group()
@click.version_option(BESPOKEASM_VERSION_STR)
def main():
    """A Bespoke ISA Assembler"""
    pass


@main.command(short_help='compile an assembly file into bytecode')
@click.argument('asm_file')
@click.option('--config-file', '-c', required=True, help='The filepath to the instruction set configuration file,')
@click.option(
        '--binary/--no-binary', '-b/-n',
        default=True,
        help='Indicates whether a binary image of the compiled bytecode should be generated.'
    )
@click.option(
        '--output-file', '-o',
        help='The filepath to where the binary image will be written. Defaults to '
             'the input file name with a *.bin extension.'
    )
@click.option(
        '--binary-min-address', '-s', default=0,
        help='The start address that will be included in the binary output. '
             'Useful for building ROM images in a given address range. Defaults to 0.'
    )
@click.option(
        '--binary-max-address', '-e', default=-1,
        help='The maximum address that will be included in the binary output. Useful '
             'for building ROM images in a given address range. Defaults to address of last generated byte code.'
    )
@click.option(
        '--binary-fill', '-f', default=0,
        help='The word value that should be used to fill empty addresses when generating binary image of '
             'a specific size.'
    )
@click.option(
        '--pretty-print', '-p',
        is_flag=True, default=False,
        help='if true, a pretty print version of the compilation will be produced.'
    )
@click.option(
        '--pretty-print-format', '-t',
        type=click.Choice(['minhex', 'hex', 'intel_hex', 'listing'], case_sensitive=False),
        default='listing',
        help='The format that should be used when pretty printing.',
)
@click.option(
        '--pretty-print-output',  default='stdout',
        help='if pretty-print is enabled, this specifies the output file. Defaults to stdout.'
    )
@click.option('--verbose', '-v', count=True, help='Verbosity of logging')
@click.option(
        '--include-path', '-I', multiple=True, default=[],
        help='Path to use when searching for included asm files. Multiple paths can be seperately specified.'
    )
@click.option(
        '--macro-symbol', '-D', multiple=True, default=[],
        help='Predefine name as macro. Assigning name with value may be done with "name=value" syntax. '
             'Multiple can be seperately specified.'
    )
def compile(
            asm_file,
            config_file,
            binary,
            output_file,
            binary_min_address,
            binary_max_address,
            binary_fill,
            pretty_print,
            pretty_print_format,
            pretty_print_output,
            verbose,
            include_path,
            macro_symbol
        ):
    if output_file is None:
        output_file = os.path.splitext(asm_file)[0] + '.bin'
    if verbose:
        click.echo(f'The file to assemble is: {asm_file}')
        if binary:
            click.echo(f'The binary image will be written to: {output_file}')
        if int(binary_min_address) > 0:
            click.echo(f'  with the starting address written: {binary_min_address}')
        if int(binary_max_address) >= 0:
            click.echo(f'  with the maximum address written: {binary_max_address}')

    asm = Assembler(
        asm_file, config_file,
        binary, output_file,
        int(binary_min_address), int(binary_max_address) if int(binary_max_address) >= 0 else None,
        binary_fill,
        pretty_print, pretty_print_format, pretty_print_output, verbose,
        include_path,
        macro_symbol,
    )
    asm.assemble_bytecode()


@main.command(short_help='update an ISA configuration file to the latest format')
@click.option(
    '--config-file', '-c', required=True,
    help='The filepath to the instruction set configuration file (YAML or JSON).'
)
@click.option(
    '--output-file', '-o',
    help='The filepath to write the updated configuration file. Defaults to stdout.'
)
def update_config(config_file, output_file):
    """Update an older ISA configuration file to the latest format and output the result."""
    import sys
    import os
    import json
    # Load config
    config_file = os.path.abspath(os.path.expanduser(config_file))
    if config_file.endswith('.json'):
        with open(config_file) as f:
            config_dict = json.load(f)
    elif config_file.endswith('.yaml') or config_file.endswith('.yml'):
        with open(config_file) as f:
            config_dict = yaml.safe_load(f)
    else:
        click.echo('ERROR: Unknown config file type. Must be .yaml, .yml, or .json.', err=True)
        sys.exit(1)
    # Update config
    updated_dict = AssemblerModel.update_config_dict_to_latest(config_dict)
    # Check for changes
    if updated_dict == config_dict:
        click.echo(
            'No changes were made to the configuration file.',
            err=True,
        )
        return
    # Output only if changes occurred
    if output_file:
        output_file = os.path.abspath(os.path.expanduser(output_file))
        with open(output_file, 'w') as f:
            if output_file.endswith('.json'):
                json.dump(updated_dict, f, indent=2)
            else:
                yaml.safe_dump(updated_dict, f, sort_keys=False)
        click.echo(f'Updated configuration written to {output_file}')
    else:
        # Default: YAML to stdout
        yaml.safe_dump(updated_dict, sys.stdout, sort_keys=False)


@main.group(short_help='generate a language syntax highlighting extension')
def generate_extension():
    pass


@generate_extension.command(short_help='generate for VisualStudio Code')
@click.option(
        '--config-file', '-c', required=True,
        help='The filepath to the instruction set configuration file,'
    )
@click.option('--verbose', '-v', count=True, help='Verbosity of logging')
@click.option(
        '--editor-config-dir', '-d', default='~/.vscode/',
        help='The file path the Visual Studo Code configuration directory containing the extensions directory.'
    )
@click.option(
        '--language-name', '-l',
        help='The name of the language in the Visual Studio Code configuration file. Defaults to value '
             'provide in instruction set configuration file.'
    )
@click.option(
        '--language-version', '-k',
        help='The version of the language in the Visual Studio Code configuration file. Defaults to '
             'value provide in instruction set configuration file.'
    )
@click.option(
        '--code-extension', '-x',
        help='The file extension for asssembly code files for this language configuraton.'
    )
def vscode(config_file, verbose, editor_config_dir, language_name, language_version, code_extension):
    config_file = os.path.abspath(os.path.expanduser(config_file))
    vscode_config_dir = os.path.abspath(os.path.expanduser(editor_config_dir))
    generator = VSCodeConfigGenerator(config_file, verbose, vscode_config_dir, language_name, language_version, code_extension)
    generator.generate()


@generate_extension.command(short_help='generate for Sublime text editor')
@click.option(
        '--config-file', '-c', required=True,
        help='The filepath to the instruction set configuration file,'
    )
@click.option('--verbose', '-v', count=True, help='Verbosity of logging')
@click.option(
        '--editor-config-dir', '-d', default='~/',
        help='The directory into which the generated configuration file should be saved.'
    )
@click.option(
        '--language-name', '-l',
        help='The name of the language in the Sublime configuration file. Defaults to value '
             'provide in instruction set configuration file.'
    )
@click.option(
        '--language-version', '-k',
        help='The version of the language in the Sublime configuration file. Defaults to value '
             'provide in instruction set configuration file.'
    )
@click.option(
        '--code-extension', '-x',
        help='The file extension for asssembly code files for this language configuraton.'
    )
def sublime(config_file, verbose, editor_config_dir, language_name, language_version, code_extension):
    config_file = os.path.abspath(os.path.expanduser(config_file))
    save_config_dir = os.path.abspath(os.path.expanduser(editor_config_dir))
    generator = SublimeConfigGenerator(config_file, verbose, save_config_dir, language_name, language_version, code_extension)
    generator.generate()


def entry_point():
    args = sys.argv
    if '--help' in args or len(args) == 1:
        click.echo('bespokeasm')
    main(auto_envvar_prefix='BESPOKEASM')


if __name__ == '__main__':
    sys.exit(entry_point())
