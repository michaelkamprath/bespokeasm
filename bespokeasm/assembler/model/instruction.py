import sys

from bespokeasm.assembler.line_identifier import LineIdentifier
from bespokeasm.assembler.byte_code.assembled import AssembledInstruction
from bespokeasm.assembler.model.operand_parser import OperandParser
from bespokeasm.assembler.model.operand_set import OperandSetCollection
from bespokeasm.assembler.byte_code.parts import NumericByteCodePart

# Instruction
#
# An instruction has two parts: mnemonic and zero or more operands. The instruction
# will generate machine code that consists first of the byte code from the mnemonic
# then each of the operands (in order), and then followed by the data generated by each
# in order.
#
# InstructionVariant
#
# An instruction variant is a configuration associated with a specific base byte code
# from the mnemonic.
#
class InstructionVariant:
    def __init__(self, mnemonic: str, instruction_variant_config: dict, operand_set_collection: OperandSetCollection, default_endian: str, variant_num: int):
        self._mnemonic = mnemonic
        self._variant_config = instruction_variant_config
        #validate config
        if 'byte_code' not in self._variant_config:
            if variant_num == 0:
                sys.exit(f'ERROR: configuration for instruction "{mnemonic}" does not have a byte code configuration')
            else:
                sys.exit(f'ERROR: configuration for instruction "{mnemonic}" does not have a byte code configuration in variant {variant_num}.')
        if 'operands' in self._variant_config:
            self._operand_parser = OperandParser(self._variant_config.get('operands', None), operand_set_collection, default_endian)
            self._operand_parser.validate(mnemonic)
        else:
            self._operand_parser = None

    @property
    def mnemonic(self) -> str:
        return self._mnemonic
    @property
    def operand_count(self) -> int:
        return self._operand_parser.operand_count
    @property
    def base_bytecode_size(self) -> int:
        return self._variant_config['byte_code']['size']
    @property
    def base_bytecode_value(self) -> int:
        return self._variant_config['byte_code']['value']

    def __repr__(self) -> str:
        return str(self)
    def __str__(self) -> str:
        operand_str = str(self._operand_parser) if self._operand_parser is not None else "NO_OPERANDS"
        return f'InstructionVariant<{self._mnemonic, operand_str}>'

    def generate_bytecode_parts(
        self,
        line_id: LineIdentifier,
        mnemonic: str,
        operands: str,
        default_endian: str,
        register_labels: set[str],
    ) -> AssembledInstruction:
        if mnemonic != self.mnemonic:
            # this shouldn't happen
            sys.exit(f'ERROR: {line_id} - INTERNAL - Asked instruction {self} to parse mnemonic "{mnemonic}"')
        if operands is not None and operands != '':
            operand_list = operands.strip().split(',')
        else:
            operand_list = []

        # generate the machine code parts
        instruction_endian = self._variant_config['byte_code'].get('endian', default_endian)
        machine_code = [NumericByteCodePart(self.base_bytecode_value, self.base_bytecode_size, True, instruction_endian, line_id)]

        if self._operand_parser is not None:
            match_found, operand_bytecode, operand_arguments = self._operand_parser.generate_machine_code(line_id, operand_list, register_labels)
            if not match_found:
                return None
            if operand_bytecode is not None:
                machine_code.extend(operand_bytecode)
            if operand_arguments is not None:
                machine_code.extend(operand_arguments)
        elif len(operand_list) > 0:
            # This variant was expecting no operands but some were found. No match.
            return None

        return AssembledInstruction(line_id, machine_code)



class Instruction:
    def __init__(self, mnemonic: str, instruction_config: dict, operand_set_collection: OperandSetCollection, default_endian: str):
        self._mnemonic = mnemonic
        self._config = instruction_config

        variant_num = 0
        self._variants: list[InstructionVariant] = []
        self._variants.append(InstructionVariant(mnemonic, instruction_config, operand_set_collection, default_endian, variant_num))

        if 'variants' in self._config:
            for variant_config in self._config['variants']:
                variant_num += 1
                self._variants.append(InstructionVariant(mnemonic, variant_config, operand_set_collection, default_endian, variant_num))


    def __repr__(self) -> str:
        return str(self)
    def __str__(self) -> str:
        return f'Instruction<{self._mnemonic}>'

    @property
    def mnemonic(self) -> str:
        return self._mnemonic

    def generate_bytecode_parts(
        self,
        line_id: LineIdentifier,
        mnemonic: str,
        operands: str,
        default_endian: str,
        register_labels: set[str],
    ) -> AssembledInstruction:
        if mnemonic != self.mnemonic:
            # this shouldn't happen
            sys.exit(f'ERROR: {line_id} - INTERNAL - Asked instruction {self} to parse mnemonic "{mnemonic}"')

        for variant in self._variants:
            assembled_instruction = variant.generate_bytecode_parts(line_id, mnemonic, operands, default_endian, register_labels)
            if assembled_instruction is not None:
                return assembled_instruction

        sys.exit(f'ERROR: {line_id} - Instruction "{mnemonic}" has no valid operands configured.')



