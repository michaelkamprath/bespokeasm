import sys

from bespokeasm.assembler.model.operand_parser import OperandParser
from bespokeasm.assembler.model.operand_set import OperandSetCollection
from bespokeasm.assembler.model.instruction_base import InstructionBase

# Instruction
#
# An instruction has two parts: mnemonic and zero or more operands. The instruction
# will generate machine code that consists first of the byte code from the mnemonic
# then each of the operands (in order), and then followed by the data generated by each
# in order.
#
# InstructionVariant
#
# An instruction variant is a configuration associated with a specific base byte code
# from the mnemonic.
#


class InstructionVariant(InstructionBase):
    def __init__(
                self,
                mnemonic: str,
                instruction_variant_config: dict,
                operand_set_collection: OperandSetCollection,
                default_endian: str,
                registers: set[str],
                variant_num: int,
            ) -> None:
        super().__init__(mnemonic, default_endian, registers)
        self._variant_config = instruction_variant_config
        # validate config
        if 'byte_code' not in self._variant_config:
            if variant_num == 0:
                sys.exit(f'ERROR: configuration for instruction "{mnemonic}" does not have a byte code configuration')
            else:
                sys.exit(
                    f'ERROR: configuration for instruction "{mnemonic}" does not have a '
                    f'byte code configuration in variant {variant_num}.'
                )
        if 'operands' in self._variant_config:
            self._operand_parser = OperandParser(
                mnemonic,
                self._variant_config.get('operands', None),
                operand_set_collection,
                default_endian,
                registers,
            )
            self._operand_parser.validate(mnemonic)
        else:
            self._operand_parser = None

    @property
    def operand_count(self) -> int:
        return self._operand_parser.operand_count

    @property
    def base_bytecode_size(self) -> int:
        return self._variant_config['byte_code']['size']

    @property
    def base_bytecode_value(self) -> int:
        return self._variant_config['byte_code']['value']

    @property
    def has_bytecode_suffix(self) -> bool:
        return 'suffix' in self._variant_config['byte_code']

    @property
    def suffix_bytecode_size(self) -> int:
        if self.has_bytecode_suffix:
            return self._variant_config['byte_code']['suffix']['size']
        else:
            return 0

    @property
    def suffix_bytecode_value(self) -> int:
        if self.has_bytecode_suffix:
            return self._variant_config['byte_code']['suffix']['value']
        else:
            return 0

    def __str__(self) -> str:
        operand_str = str(self._operand_parser) if self._operand_parser is not None else "NO_OPERANDS"
        return f'InstructionVariant<{self._mnemonic, operand_str}>'


class Instruction(InstructionBase):
    def __init__(
                self,
                mnemonic: str,
                instruction_config: dict,
                operand_set_collection: OperandSetCollection,
                default_endian: str,
                registers: set[str]
            ) -> None:
        super().__init__(mnemonic, default_endian, registers)
        self._config = instruction_config

        variant_num = 0
        self._variants: list[InstructionVariant] = []
        self._variants.append(
            InstructionVariant(
                mnemonic,
                instruction_config,
                operand_set_collection,
                default_endian,
                registers,
                variant_num
            )
        )

        if 'variants' in self._config:
            for variant_config in self._config['variants']:
                variant_num += 1
                self._variants.append(
                    InstructionVariant(
                        mnemonic,
                        variant_config,
                        operand_set_collection,
                        default_endian,
                        registers,
                        variant_num
                    )
                )

    @property
    def variants(self) -> list[InstructionVariant]:
        return self._variants

    def __str__(self) -> str:
        return f'Instruction<{self._mnemonic}>'
