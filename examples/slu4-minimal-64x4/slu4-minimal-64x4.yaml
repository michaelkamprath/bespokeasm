---
description: slu4 Minimal 64x4 Home Computer
general:
  address_size: 16
  endian: little
  registers:
    - a
    - b
    - bank
  origin: 0x0000
  identifier:
    name: slu4-min64x4-asm
    version: "1.1.0"
    extension: min64
  min_version: "0.4.2"
operand_sets:
  immediate_8bit:
    # one byte is interpreted as an immediate value
    operand_values:
      int8:
        type: numeric
        argument:
          size: 8
          byte_align: true
          endian: little
  immediate_16bit:
    # 2 bytes is interpreted as an immediate value
    operand_values:
      int8:
        type: numeric
        argument:
          size: 16
          byte_align: true
          endian: little
  immediate_32bit:
    # 4 bytes is interpreted as an immediate value
    operand_values:
      int8:
        type: numeric
        argument:
          size: 32
          byte_align: true
          endian: little
  absolute_address:
    # two bytes are interpreted as an address
    operand_values:
      address:
        type: address
        argument:
          size: 16
          byte_align: true
          endian: little
  relative_address:
    # two byte is interpreted as a relative address
    operand_values:
      address:
        type: address
        argument:
          size: 16
          byte_align: true
          endian: little
  address_lsb:
    # one byte is interpreted as an address's LSB and the address MSB is taken from the current instruction address
    operand_values:
      address:
        type: address
        argument:
          size: 8
          byte_align: true
          endian: little
          slice_lsb: true
  offset:
    # one byte is interpreted as an offset
    operand_values:
      int8:
        type: numeric
        argument:
          size: 8
          byte_align: true
          endian: little
  zero_page:
    # one byte is interpreted as a zero page address
    operand_values:
      address:
        type: address
        argument:
          size: 8
          byte_align: true
          endian: little
          slice_lsb: true
          memory_zone: ZERO_PAGE
  relative_zero_page:
    # one byte is interpreted as a zero page address to a word that in turn is used as a relative address
    operand_values:
      address:
        type: address
        argument:
          size: 8
          byte_align: true
          endian: little
          slice_lsb: true
          memory_zone: ZERO_PAGE
predefined:
  memory_zones:
    - name: ZERO_PAGE
      start: 0x0000
      end: 0x00FF
  constants:
    -  # Start vector of the OS in RAM
      name: _Start
      value: 0xf000
    -  # Hands back control to the input prompt
      name: _Prompt
      value: 0xf003
    -  # Moves memory area (may be overlapping)
      name: _MemMove
      value: 0xf006
    -  # Returns a pseudo-random byte (see _RandomState)
      name: _Random
      value: 0xf009
    -  # Scans the PS/2 register for new input
      name: _ScanPS2
      value: 0xf00c
    -  # Resets the state of PS/2 SHIFT, ALTGR, CTRL
      name: _ResetPS2
      value: 0xf00f
    -  # Reads any input (PS/2 or serial)
      name: _ReadInput
      value: 0xf012
    -  # Waits for any input (PS/2 or serial)
      name: _WaitInput
      value: 0xf015
    -  # Reads a command line into _ReadBuffer
      name: _ReadLine
      value: 0xf018
    -  # Skips whitespaces (<= 39) in command line
      name: _SkipSpace
      value: 0xf01b
    -  # Parses command line input for a HEX value
      name: _ReadHex
      value: 0xf01e
    -  # Waits for a UART transmission to complete
      name: _SerialWait
      value: 0xf021
    -  # Transmits a zero-terminated string via UART
      name: _SerialPrint
      value: 0xf024
    -  # Searches for file <name> given by _ReadPtr
      name: _FindFile
      value: 0xf027
    -  # Loads a file <name> given by _ReadPtr
      name: _LoadFile
      value: 0xf02a
    -  # Saves data to file <name> defined at _ReadPtr
      name: _SaveFile
      value: 0xf02d
    -  # Clears the video RAM including blanking areas
      name: _ClearVRAM
      value: 0xf030
    -  # Clears the visible video RAM (viewport)
      name: _Clear
      value: 0xf033
    -  # Clears the current row from cursor pos onwards
      name: _ClearRow
      value: 0xf036
    -  # Scrolls up the viewport by 8 pixels
      name: _ScrollUp
      value: 0xf039
    - # Scrolls down the viewport by 8 pixels
      name: _ScrollDn
      value: 0xf03c
    -  # Outputs a char at the cursor pos (non-advancing)
      name: _Char
      value: 0xf03f
    -  # Prints a char at the cursor pos (advancing)
      name: _PrintChar
      value: 0xf042
    -  # Prints a zero-terminated immediate string
      name: _Print
      value: 0xf045
    -  # Prints a zero-terminated string at an address
      name: _PrintPtr
      value: 0xf048
    -  # Prints a HEX number (advancing)
      name: _PrintHex
      value: 0xf04b
    -  # Sets a pixel at position (x, y)
      name: _SetPixel
      value: 0xf04e
    -  # Draws a line using Bresenham’s algorithm
      name: _Line
      value: 0xf051
    -  # Draws a rectangle at (x, y) of size (w, h)
      name: _Rect
      value: 0xf054
    -  # Clears a pixel at position (x, y)
      name: _ClearPixel
      value: 0xf057
    - # Horizontal cursor position (see _Print)
      name: _XPos
      value: 0x00c0
    -  # Vertical cursor position (see _Print)
      name: _YPos
      value: 0x00c1
    -  # _Random state seed
      name: _RandomState
      value: 0x00c2
    -  # Number parsed by _ReadHex
      name: _ReadNum
      value: 0x00c6
    -  # Command line parsing pointer
      name: _ReadPtr
      value: 0x00c9
    -  # Address of command line input buffer
      name: _ReadBuffer
      value: 0x00cd


# Instruction DEC
# Instruction HEX
# Instruction Mnemonic
# Description
# Operand

# 0
# 0x00
# NOP
# No operation
# -


# 1
# 0x01
# OUT
# Output A to UART: UART = A
# -


# 2
# 0x02
# INT
# Read UART input to A: A = UART
# -


# 3
# 0x03
# INK
# Read PS/2 input to A: A = PS2
# -


# 4
# 0x04
# WIN
# Wait for input
# -


# 5
# 0x05
# SEC
# Set carry flag (C=1)
# -


# 6
# 0x06
# CLC
# Clear carry flag (C=0)
# -


# 7
# 0x07
# LL0
# Logical left-shift A 0 steps (C=0)
# -


# 8
# 0x08
# LL1
# Logical left-shift A 1 step (C=0)
# -


# 9
# 0x09
# LL2
# Logical left-shift A 2 steps (C=0)
# -


# 10
# 0x0a
# LL3
# Logical left-shift A 3 steps (C=0)
# -


# 11
# 0x0b
# LL4
# Logical left-shift A 4 steps (C=0)
# -


# 12
# 0x0c
# LL5
# Logical left-shift A 5 steps (C=0)
# -


# 13
# 0x0d
# LL6
# Logical left-shift A 6 steps (C=0)
# -


# 14
# 0x0e
# LL7
# Logical left-shift A 7 steps (C=0)
# -


# 15
# 0x0f
# RL0
# Rotate left A 0 steps via C (= RR9)
# -


# 16
# 0x10
# RL1
# Rotate left A 1 step via C (= RR8)
# -


# 17
# 0x11
# RL2
# Rotate left A 2 steps via C (= RR7)
# -


# 18
# 0x12
# RL3
# Rotate left A 3 steps via C (= RR6)
# -


# 19
# 0x13
# RL4
# Rotate left A 4 steps via C (= RR5)
# -


# 20
# 0x14
# RL5
# Rotate left A 5 steps via C (= RR4)
# -


# 21
# 0x15
# RL6
# Rotate left A 6 steps via C (= RR3)
# -


# 22
# 0x16
# RL7
# Rotate left A 7 steps via C (= RR2)
# -


# 23
# 0x17
# RR1
# Rotate right A 1 step via C (= RL8)
# -


# 24
# 0x18
# LR0
# Logical right-shift A 0 steps (C=0) (= RR0, RL9)
# -


# 25
# 0x19
# LR1
# Logical right-shift A 1 step (C=0)
# -


# 26
# 0x1a
# LR2
# Logical right-shift A 2 steps (C=0)                 §
# -


# 27
# 0x1b
# LR3
# Logical right-shift A 3 steps (C=0)                 §
# -


# 28
# 0x1c
# LR4
# Logical right-shift A 4 steps (C=0)                 §
# -


# 29
# 0x1d
# LR5
# Logical right-shift A 5 steps (C=0)                 §
# -


# 30
# 0x1e
# LR6
# Logical right-shift A 6 steps (C=0)                 §
# -


# 31
# 0x1f
# LR7
# Logical right-shift A 7 steps (C=0)
# -


# 32
# 0x20
# LLZ
# Logical shift left *Z 1 step (C=0)
# Z


# 33
# 0x21
# LLB
# Logical shift byte left 1 step (C=0)
# addr


# 34
# 0x22
# LLV
# Logical shift fast word left 1 step (C=0)
# V


# 35
# 0x23
# LLW
# Logical shift word left 1 step (C=0)
# addr


# 36
# 0x24
# LLQ
# Logical shift fast long left 1 step (C=0)
# Q


# 37
# 0x25
# LLL
# Logical shift long left 1 step (C=0)
# addr


# 38
# 0x26
# LRZ
# Logical shift right zero-page byte 1 step (C=0)
# Z


# 39
# 0x27
# LRB
# Logical shift right abs byte 1 step (C=0)
# addr


# 40
# 0x28
# RLZ
# Rotate left zero-page byte 1 step via C
# Z


# 41
# 0x29
# RLB
# Rotate left byte at abs addr 1 step via C
# addr


# 42
# 0x2a
# RLV
# Rotate left zero-page word 1 step via C
# V


# 43
# 0x2b
# RLW
# Rotate left word at abs addr 1 step via C
# addr


# 44
# 0x2c
# RLQ
# Rotate left zero-page long 1 step via C
# Q


# 45
# 0x2d
# RLL
# Rotate left abs long 1 step via C
# addr


# 46
# 0x2e
# RRZ
# Rotate right zero-page byte 1 step via C
# Z


# 47
# 0x2f
# RRB
# Rotate right byte at abs addr 1 step via C
# addr


# 48
# 0x30
# NOT
# Bitwise NOT A: A = ~A
# -


# 49
# 0x31
# NOZ
# Bitwise NOT Z: *Z = ~(*Z)
# Z


# 50
# 0x32
# NOB
# Bitwise NOT byte: *addr = ~(*addr)
# addr


# 51
# 0x33
# NOV
# Bitwise NOT zero-page word: *V = ~(*V)
# V


# 52
# 0x34
# NOW
# Bitwise NOT word at abs address
# addr


# 53
# 0x35
# NOQ
# Bitwise NOT zero-page long
# Q


# 54
# 0x36
# NOL
# Bitwise NOT long at abs address
# addr


# 55
# 0x37
# NEG
# Negate A: A = -A
# -


# 56
# 0x38
# NEZ
# Negate zero-page byte: *Z = -(*Z)
# Z


# 57
# 0x39
# NEB
# Negate byte at abs address: *addr = -(*addr)
# addr


# 58
# 0x3a
# NEV
# Negate zero-page word (C = 1 only if word=0)
# V


# 59
# 0x3b
# NEW
# Negate word at abs address (C = 1 only if word=0)
# addr


# 60
# 0x3c
# NEQ
# Negate zero-page long (C = 1 only if long = 0)
# Q


# 61
# 0x3d
# NEL
# Negate long (C = 1 only if long = 0)
# addr


# 62
# 0x3e
# ANI
# Bitwise AND: A = A & imm
# imm


# 63
# 0x3f
# ANZ
# Bitwise AND: A = A & *Z
# Z


# 64
# 0x40
# ANB
# Bitwise AND: A = A & *addr
# addr


# 65
# 0x41
# ANT
# Bitwise AND: A = A & *(*Z)
# rel Z


# 66
# 0x42
# ANR
# Bitwise AND: A = A & *(*addr)
# rel addr


# 67
# 0x43
# AN.Z
# Bitwise AND: *Z = *Z & A
# Z


# 68
# 0x44
# AN.B
# Bitwise AND: *addr = *addr & A
# addr


# 69
# 0x45
# ORI
# Bitwise OR: A = A | imm
# imm


# 70
# 0x46
# ORZ
# Bitwise OR: A = A | *Z
# Z


# 71
# 0x47
# ORB
# Bitwise OR: A = A | *addr
# addr


# 72
# 0x48
# ORT
# Bitwise OR: A = A | *(*Z)
# rel Z


# 73
# 0x49
# ORR
# Bitwise OR: A = A | *(*addr)
# rel addr


# 74
# 0x4a
# OR.Z
# Bitwise OR: *Z = *Z | A
# Z


# 75
# 0x4b
# OR.B
# Bitwise OR: *addr = *addr | A
# addr


# 76
# 0x4c
# XRI
# Bitwise XOR: A = A ^ imm                            §
# imm


# 77
# 0x4d
# XRZ
# Bitwise XOR: A = A ^ *Z
# Z


# 78
# 0x4e
# XRB
# Bitwise XOR: A = A ^ * addr                         §
# addr


# 79
# 0x4f
# XRT
# Bitwise XOR: A = A ^ *(*Z)
# rel Z


# 80
# 0x50
# XRR
# Bitwise XOR: A = A ^ *(*addr)                       §
# rel addr


# 81
# 0x51
# XR.Z
# Bitwise XOR: *Z = *Z ^ A
# Z


# 82
# 0x52
# XR.B
# Bitwise XOR: *addr = *addr ^ A
# addr


# 83
# 0x53
# FNE
# Fast branch on non-zero
# addr lsb


# 84
# 0x54
# FEQ
# Fast branch on zero
# addr lsb


# 85
# 0x55
# FCC
# Fast branch on carry clear
# addr lsb


# 86
# 0x56
# FCS
# Fast branch on carry set
# addr lsb


# 87
# 0x57
# FPL
# Fast branch on plus
# addr lsb


# 88
# 0x58
# FMI
# Fast branch on minus
# addr lsb


# 89
# 0x59
# FGT
# Fast branch on greater
# addr lsb


# 90
# 0x5a
# FLE
# Fast branch on less or equal
# addr lsb


# 91
# 0x5b
# FPA
# Fast jump to lsb addr
# addr lsb


# 92
# 0x5c
# BNE
# Branch on non-zero
# addr


# 93
# 0x5d
# BEQ
# Branch on zero
# addr


# 94
# 0x5e
# BCC
# Branch on carry clear
# addr


# 95
# 0x5f
# BCS
# Branch on carry set
# addr


# 96
# 0x60
# BPL
# Branch on plus
# addr


# 97
# 0x61
# BMI
# Branch on minus
# addr


# 98
# 0x62
# BGT
# Branch on greater
# addr


# 99
# 0x63
# BLE
# Branch on less or equal
# addr


# 100
# 0x64
# JPA
# Jump to abs address: PC = addr
# addr


# 101
# 0x65
# JPR
# Jump to rel address: PC = *addr
# rel addr


# 102
# 0x66
# JAR
# Jump A-indexed to rel address: PC = *(addr + A)
# rel addr


# 103
# 0x67
# JPS
# Jump to subroutine
# addr


# 104
# 0x68
# JAS
# Jump to subroutine conserving A                     §
# addr


# 105
# 0x69
# RTS
# Return from subroutine
# -


# 106
# 0x6a
# PHS
# Push A onto stack
# -


# 107
# 0x6b
# PLS
# Pull A from stack
# -


# 108
# 0x6c
# LDS
# Load from stack: A = *(0xff00 + SP + off)
# offset


# 109
# 0x6d
# STS
# Store on stack: *(0xff00 + SP + off) = A
# offset


# 110
# 0x6e
# RDB
# Read FLASH data from abs 3-byte address
# addr,bnk


# 111
# 0x6f
# RDR
# Read FLASH data from rel 3-byte address
# rel addr


# 112
# 0x70
# RAP
# Read A-indexed FLASH data: A = *(pg<<8 + A)
# pg,bnk


# 113
# 0x71
# RZP
# Read Z-indexed FLASH data: A = *(pg<<8 + *Z)
# Z,pg,bnk


# 114
# 0x72
# WDB
# Write FLASH data to abs 3-byte address              §
# addr,bnk


# 115
# 0x73
# WDR
# Write FLASH data to rel 3-byte address              §
# rel addr


# 116
# 0x74
# LDI
# Load A immediate: A = imm
# imm


# 117
# 0x75
# LDZ
# Load A from Z: A = *Z
# Z


# 118
# 0x76
# LDB
# Load A from abs address: A = *addr
# addr


# 119
# 0x77
# LDT
# Load A from rel address in zero page: A = *(*Z)
# rel Z


# 120
# 0x78
# LDR
# Load A from relative address: A = *(*addr)
# rel addr


# 121
# 0x79
# LAP
# Load A A-indexed from page: A = *(pg<<8 + A)
# pg


# 122
# 0x7a
# LAB
# Load A A-indexed from addr: A = *(addr + A)
# addr


# 123
# 0x7b
# LZP
# Load A Z-indexed from page: A = *(pg<<8 + *Z)
# Z,pg


# 124
# 0x7c
# LZB
# Load A Z-indexed from addr: A = *(addr + *Z)
# Z,addr


# 125
# 0x7d
# STZ
# Store A to Z: *Z = A
# Z


# 126
# 0x7e
# STB
# Store A to address: *addr = A
# addr


# 127
# 0x7f
# STT
# Store A at rel address in zero page: *(*Z) = A
# rel Z


# 128
# 0x80
# STR
# Store A at relative address: *(*addr) = A
# rel addr


# 129
# 0x81
# SZP
# Store A Z-indexed to page: *(pg<<8 + *Z) = A
# Z,pg


# 130
# 0x82
# MIZ
# Move imm byte to zero-page: *Z = imm
# imm,Z


# 131
# 0x83
# MIB
# Move imm byte to abs addr: *addr = imm
# imm,addr


# 132
# 0x84
# MIT
# Move imm byte to rel zero-page addr: *(*T) = imm
# imm,rel Z


# 133
# 0x85
# MIR
# Move imm byte to rel addr: *(*addr) = imm
# imm,rel


# 134
# 0x86
# MIV
# Move imm word to zero-page word: *V = imm
# imm,V


# 135
# 0x87
# MIW
# Move imm word to abs addr: *addr = imm
# imm,addr


# 136
# 0x88
# MZZ
# Move zero-page byte to zero-page byte: *Z2 = *Z1
# Z1,Z2


# 137
# 0x89
# MZB
# Move zero-page byte to abs addr: *addr = *Z
# Z,addr


# 138
# 0x8a
# MBZ
# Move byte at abs addr to zero-page: *Z = *addr
# addr,Z


# 139
# 0x8b
# MBB
# Move byte from abs adr1 to abs adr2: *adr2 = *adr1
# adr1,adr2


# 140
# 0x8c
# MVV
# Move zero-page word to zero-page word: *V2 = *V1
# V1,V2


# 141
# 0x8d
# MWV
# Move word at abs addr to fast word: *V = *addr
# addr,V


# 142
# 0x8e
# CLZ
# Clear Z: *Z = 0x00
# Z


# 143
# 0x8f
# CLB
# Clear byte at addr: *addr = 0x00
# addr


# 144
# 0x90
# CLV
# Clear fast word: *V = 0x0000
# V


# 145
# 0x91
# CLW
# Clear word at addr: *addr = 0x0000
# addr


# 146
# 0x92
# CLQ
# Clear zero-page long: *Q = 0x00000000
# Q


# 147
# 0x93
# CLL
# Clear long: *addr = 0x00000000
# addr


# 148
# 0x94
# INC
# Increment A: A = A + 1
# -


# 149
# 0x95
# INZ
# Increment zero-page byte: *Z = *Z + 1
# Z


# 150
# 0x96
# INB
# Increment byte at abs addr: *addr = *addr + 1
# addr


# 151
# 0x97
# INV
# Increment zero-page word: *V = *V + 0x0001
# V


# 152
# 0x98
# INW
# Increment word at abs addr: *addr = *addr + 0x0001
# addr


# 153
# 0x99
# INQ
# Increment zero-page long: *Q = *Q + 0x00000001
# Q


# 154
# 0x9a
# INL
# Increment long: *addr = *addr + 0x00000001
# addr


# 155
# 0x9b
# DEC
# Decrement A: A = A - 1
# -


# 156
# 0x9c
# DEZ
# Decrement *Z = *Z - 1
# Z


# 157
# 0x9d
# DEB
# Decrement byte: *addr = *addr - 1
# addr


# 158
# 0x9e
# DEV
# Decrement zero-page word: *V = *V - 0x0001
# V


# 159
# 0x9f
# DEW
# Decrement word at abs addr: *addr = *addr - 0x0001
# addr


# 160
# 0xa0
# DEQ
# Decrement zero-page long: *Q = *Q - 0x00000001
# Q


# 161
# 0xa1
# DEL
# Decrement long: *addr = *addr - 0x00000001
# addr


# 162
# 0xa2
# ADI
# Add immediate to A: A = A + imm
# imm


# 163
# 0xa3
# ADZ
# Add zero-page byte to A: A = A + *Z
# Z


# 164
# 0xa4
# ADB
# Add byte at addr to A: A = A + *addr
# addr


# 165
# 0xa5
# ADT
# Add byte at rel zero-page addr to A: A = A + *(*Z)
# rel Z


# 166
# 0xa6
# ADR
# Add byte at rel addr to A: A = A + *(*addr)
# rel addr


# 167
# 0xa7
# AD.Z
# Add A to zero-page byte: *Z = *Z + A
# Z


# 168
# 0xa8
# AD.B
# Add A to byte at abs addr: *addr = *addr + A
# addr


# 169
# 0xa9
# AD.T
# Add A to rel zero-page address: *(*Z) = *(*Z) + A
# rel Z


# 170
# 0xaa
# AD.R
# Add A to rel address: *(*addr) = *(*addr) + A
# rel addr


# 171
# 0xab
# ADV
# Add A to zero-page word: *V = *V + A
# V


# 172
# 0xac
# ADW
# Add A to word at abs addr: *addr = *addr + A
# addr


# 173
# 0xad
# ADQ
# Add A to zero-page long: *Q = *Q + A
# Q


# 174
# 0xae
# ADL
# Add A to long: *addr = *addr + A
# addr


# 175
# 0xaf
# AIZ
# Add immediate to zero-page byte: *Z = *Z + imm
# imm,Z


# 176
# 0xb0
# AIB
# Add imm to byte at abs addr: *addr = *addr + Z
# imm,addr


# 177
# 0xb1
# AIT
# Add imm to byte at rel Z addr: *(*Z) = *(*Z) + imm
# imm,rel Z


# 178
# 0xb2
# AIR
# Add imm to byte at rel addr: *(*adr) = *(*adr) + imm
# imm,rel


# 179
# 0xb3
# AIV
# Add immediate byte to zero-page word: *V = *V + imm
# imm,V


# 180
# 0xb4
# AIW
# Add imm byte to abs word: *addr = *addr + im,m
# imm,addr


# 181
# 0xb5
# AIQ
# Add immediate byte to zero-page long: *Q = *Q + imm
# imm,Q


# 182
# 0xb6
# AIL
# Add immediate byte to long: *L = *L + imm
# imm,addr


# 183
# 0xb7
# AZZ
# Add zero-page byte to zero-page byte: *Z2 = *Z2 + *Z1
# Z1,Z2


# 184
# 0xb8
# AZB
# Add zero-page to byte at abs addr: *addr = *addr + Z
# Z,addr


# 185
# 0xb9
# AZV
# Add zero-page byte to zero-page word: *V = *V + *Z
# Z,V


# 186
# 0xba
# AZW
# Add zero-page byte to word at addr: *addr = *addr + Z
# Z,addr


# 187
# 0xbb
# AZQ
# Add zero-page byte to zero-page long: *Q = *Q + *Z
# Z,Q


# 188
# 0xbc
# AZL
# Add zero-page byte to long: *L = *L + Z
# Z,addr


# 189
# 0xbd
# ABZ
# Add abs byte to zero-page byte: *Z = *Z + *addr
# addr,Z


# 190
# 0xbe
# ABB
# Add abs byte to byte: *adr2 = *adr2 + *adr1
# adr1,adr2


# 191
# 0xbf
# ABV
# Add abs byte to zero-page word: *V = *V + *addr
# addr,V


# 192
# 0xc0
# ABW
# Add byte at ad1 to word at ad2: *ad2 = *ad2 + *ad1
# ad1,ad2


# 193
# 0xc1
# ABQ
# Add abs byte to zero-page long: *Q = *Q + *addr
# addr,Q


# 194
# 0xc2
# AVV
# Add zero-page word to zero-page word: *V2 = *V2 + *V1
# V1,V2


# 195
# 0xc3
# SUI
# Sub immediate from A: A = A - imm
# imm


# 196
# 0xc4
# SUZ
# Sub zero-page byte from A: A = A - *Z
# Z


# 197
# 0xc5
# SUB
# Sub byte at addr from A: A = A - *addr
# addr


# 198
# 0xc6
# SUT
# Sub byte at rel zero-page addr from A: A = A - *(*Z)
# rel Z


# 199
# 0xc7
# SUR
# Sub byte at rel addr from A: A = A - *(*addr)
# rel addr


# 200
# 0xc8
# SU.Z
# Sub A from zero-page byte: *Z = *Z - A
# Z


# 201
# 0xc9
# SU.B
# Sub A from byte at abs addr: *addr = *addr - A
# addr


# 202
# 0xca
# SU.T
# Sub A from rel zero-page address: *(*Z) = *(*Z) - A
# rel Z


# 203
# 0xcb
# SU.R
# Sub A from byte at rel addr: *(*addr) = *(*addr) - A
# rel addr


# 204
# 0xcc
# SUV
# Sub A from zero-page word: *v = *V - A
# V


# 205
# 0xcd
# SUW
# Sub A from word at abs addr: *addr = *addr - A
# addr


# 206
# 0xce
# SUQ
# Sub A from zero-page long: *Q = *Q - A
# Q


# 207
# 0xcf
# SU.L
# Sub A from long: *addr = *addr - A
# addr


# 208
# 0xd0
# SIZ
# Sub immediate from zero-page byte: *Z = *Z - imm
# imm,Z


# 209
# 0xd1
# SIB
# Sub imm from byte: *addr = *addr - Z
# imm,addr


# 210
# 0xd2
# SIT
# Sub imm from byte at rel Z addr: *(*Z) = *(*Z) + imm
# imm,rel Z


# 211
# 0xd3
# SIR
# Sub imm from byte at rel addr: *(*ad) = *(*ad) + imm
# imm,addr


# 212
# 0xd4
# SIV
# Sub imm byte from zero-page word: *V = *V - imm
# imm,V


# 213
# 0xd5
# SIW
# Sub imm byte from abs word: *addr = *addr - imm
# imm,addr


# 214
# 0xd6
# SIQ
# Sub imm byte from zero-page long Z: *Z = *Z - imm
# imm,Q


# 215
# 0xd7
# SIL
# Sub imm byte from long at abs address
# imm,addr


# 216
# 0xd8
# SZZ
# Sub zero-page byte from Z byte: *Z2 = *Z2 - *Z1
# Z1,Z2


# 217
# 0xd9
# SZB
# Sub zero-page byte from abs byte: *addr = *addr - Z
# Z,addr


# 218
# 0xda
# SZV
# Sub zero-page byte from zero-page word: *V = *V - *Z
# Z,V


# 219
# 0xdb
# SZW
# Sub zero-page byte from abs word: *addr = *addr - Z
# Z,addr


# 220
# 0xdc
# SZQ
# Sub zero-page byte from zero-page long: *Q = *Q - *Z
# Z,Q


# 221
# 0xdd
# SZL
# Sub zero-page byte from long: *L = *L - Z
# Z,addr


# 222
# 0xde
# SBZ
# Sub abs byte from zero-page byte: *Z = *Z - *addr
# addr,Z


# 223
# 0xdf
# SBB
# Sub abs byte from byte: *adr2 = *adr2 - *adr1
# adr1,adr2


# 224
# 0xe0
# SBV
# Sub abs byte from zero-page word: *V = *V - *addr
# addr,V


# 225
# 0xe1
# SBW
# Sub abs byte from word at adr2: *adr2 = *adr2 - *adr1
# adr1,adr2


# 226
# 0xe2
# SBQ
# Sub abs byte from zero-page long: *Q = *Q - *addr
# addr,Q


# 227
# 0xe3
# SVV
# Sub zero-page word from word: *V2 = *V2 - *V1
# V1,V2


# 228
# 0xe4
# CPI
# Compare immediate value to A: eval A - imm
# imm


# 229
# 0xe5
# CPZ
# Compare zero-page byte to A: eval A - *Z
# Z


# 230
# 0xe6
# CPB
# Compare byte at addr to A: eval A - *addr
# addr


# 231
# 0xe7
# CPT
# Compare byte at rel Z to A: eval A - *(*Z)
# rel Z


# 232
# 0xe8
# CPR
# Compare rel byte to A: eval A - *(*addr)
# rel addr


# 233
# 0xe9
# CIZ
# Compare imm to zero-page byte: A = *Z - imm
# imm,Z


# 234
# 0xea
# CIB
# Compare imm to byte at abs addr: A = *addr - imm
# imm,addr


# 235
# 0xeb
# CIT
# Compare imm to byte at rel Z: A = *(*Z) - imm
# imm,rel Z


# 236
# 0xec
# CIR
# Compare imm to byte at rel addr: A = *(*addr) - imm
# imm,addr


# 237
# 0xed
# CZZ
# Compare zero-page byte to byte: A = *Z2 - *Z1
# Z1,Z2


# 238
# 0xee
# CZB
# Compare zero-page byte to byte: A = *addr - Z
# Z,addr


# 239
# 0xef
# CBZ
# Compare abs byte to zero-page byte: A = *addr - *Z
# addr,Z


# 240
# 0xf0
# CBB
# Compare abs byte to byte: A = *adr2 - *adr1
# adr1,adr2


# 241
# 0xf1
# ACI
# Add immediate value to A with C: A = A + imm + C
# imm


# 242
# 0xf2
# ACZ
# Add zero-page byte with C to A: A = A + *Z + C
# Z


# 243
# 0xf3
# ACB
# Add byte at addr with C to A: A = A + *addr + C
# addr


# 244
# 0xf4
# AC.Z
# Add A with C to zero-page byte: *Z = *Z + A + C
# Z


# 245
# 0xf5
# AC.B
# Add A with C to byte at addr: *addr = *addr + A + C
# addr


# 246
# 0xf6
# ACV
# Add A with C to zero-page word
# V


# 247
# 0xf7
# ACW
# Add A with C to word at ads addr: *adr = *adr + A + C
# addr


# 248
# 0xf8
# SCI
# Sub imm value from A with C: A = A - imm - 1 + C
# imm


# 249
# 0xf9
# SCZ
# Sub zero-page byte with C from A: A = A - *Z - 1 + C
# Z


# 250
# 0xfa
# SCB
# Sub byte at addr from A with C: A = A - *addr - 1 + C
# addr


# 251
# 0xfb
# SC.Z
# Sub A with C from zero-page byte: *Z = *Z - A - 1 + C
# Z


# 252
# 0xfc
# SC.B
# Sub A with C from byte: *addr = *addr - A - 1 + C
# addr


# 253
# 0xfd
# SCV
# Sub A with C from zero-page word
# V


# 254
# 0xfe
# SCW
# Sub A with C from word at abs addr
# addr


# 255
# 0xff
# -
# Set bank register to 0xff (FLASH OFF) after boot-up
# -







instructions:
  nop:
    # No operation
    bytecode:
      value: 0x00
      size: 8
  out:
    # Output A to UART: UART = A
    bytecode:
      value: 0x01
      size: 8
  int:
    # Read UART input to A: A = UART
    bytecode:
      value: 0x02
      size: 8
  ink:
    # Read PS/2 input to A: A = PS2
    bytecode:
      value: 0x03
      size: 8
  win:
    # Wait for input
    bytecode:
      value: 0x04
      size: 8
  sec:
    # Set carry flag (C=1)
    bytecode:
      value: 0x05
      size: 8
  clc:
    # Clear carry flag (C=0)
    bytecode:
      value: 0x06
      size: 8
  ll0:
    # Logical left-shift A 0 steps (C=0)
    bytecode:
      value: 0x07
      size: 8
  ll1:
    # Logical left-shift A 1 step (C=0)
    bytecode:
      value: 0x08
      size: 8
  ll2:
    # Logical left-shift A 2 steps (C=0)
    bytecode:
      value: 0x09
      size: 8
  ll3:
    # Logical left-shift A 3 steps (C=0)
    bytecode:
      value: 0x0a
      size: 8
  ll4:
    # Logical left-shift A 4 steps (C=0)
    bytecode:
      value: 0x0b
      size: 8
  ll5:
    # Logical left-shift A 5 steps (C=0)
    bytecode:
      value: 0x0c
      size: 8
  ll6:
    # Logical left-shift A 6 steps (C=0)
    bytecode:
      value: 0x0d
      size: 8
  ll7:
    # Logical left-shift A 7 steps (C=0)
    bytecode:
      value: 0x0e
      size: 8
  rl0:
    # Rotate left A 0 steps via C (= RR9)
    bytecode:
      value: 0x0f
      size: 8
  rl1:
    # Rotate left A 1 step via C (= RR8)
    bytecode:
      value: 0x10
      size: 8
  rl2:
    # Rotate left A 2 steps via C (= RR7)
    bytecode:
      value: 0x11
      size: 8
  rl3:
    # Rotate left A 3 steps via C (= RR6)
    bytecode:
      value: 0x12
      size: 8
  rl4:
    # Rotate left A 4 steps via C (= RR5)
    bytecode:
      value: 0x13
      size: 8
  rl5:
    # Rotate left A 5 steps via C (= RR4)
    bytecode:
      value: 0x14
      size: 8
  rl6:
    # Rotate left A 6 steps via C (= RR3)
    bytecode:
      value: 0x15
      size: 8
  rl7:
    # Rotate left A 7 steps via C (= RR2)
    bytecode:
      value: 0x16
      size: 8
  rr1:
    # Rotate right A 1 step via C (= RL8)
    bytecode:
      value: 0x17
      size: 8
  lr0:
    # Logical right-shift A 0 steps (C=0) (= RR0, RL9)
    bytecode:
      value: 0x18
      size: 8
  lr1:
    # Logical right-shift A 1 step (C=0)
    bytecode:
      value: 0x19
      size: 8
  lr2:
    # Logical right-shift A 2 steps (C=0)
    bytecode:
      value: 0x1a
      size: 8
  lr3:
    # Logical right-shift A 3 steps (C=0)
    bytecode:
      value: 0x1b
      size: 8
  lr4:
    # Logical right-shift A 4 steps (C=0)
    bytecode:
      value: 0x1c
      size: 8
  lr5:
    # Logical right-shift A 5 steps (C=0)
    bytecode:
      value: 0x1d
      size: 8
  lr6:
    # Logical right-shift A 6 steps (C=0)
    bytecode:
      value: 0x1e
      size: 8
  lr7:
    # Logical right-shift A 7 steps (C=0)
    bytecode:
      value: 0x1f
      size: 8
  llz:
    # Logical shift left *Z 1 step (C=0)
    bytecode:
      value: 0x20
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  llb:
    # Logical shift byte left 1 step (C=0)
    bytecode:
      value: 0x21
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  llv:
    # Logical shift fast word left 1 step (C=0)
    bytecode:
      value: 0x22
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  llw:
    # Logical shift word left 1 step (C=0)
    bytecode:
      value: 0x23
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  llq:
    # Logical shift fast long left 1 step (C=0)
    bytecode:
      value: 0x24
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  lll:
    # Logical shift long left 1 step (C=0)
    bytecode:
      value: 0x25
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  lrz:
    # Logical shift right zero-page byte 1 step (C=0)
    bytecode:
      value: 0x26
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  lrb:
    # Logical shift right abs byte 1 step (C=0)
    bytecode:
      value: 0x27
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  rlz:
    # Rotate left zero-page byte 1 step via C
    bytecode:
      value: 0x28
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  rlb:
    # Rotate left byte at abs addr 1 step via C
    bytecode:
      value: 0x29
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  rlv:
    # Rotate left zero-page word 1 step via C
    bytecode:
      value: 0x2a
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  rlw:
    # Rotate left word at abs addr 1 step via C
    bytecode:
      value: 0x2b
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  rlq:
    # Rotate left zero-page long 1 step via C
    bytecode:
      value: 0x2c
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  rll:
    # Rotate left abs long 1 step via C
    bytecode:
      value: 0x2d
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  rrz:
    # Rotate right zero-page byte 1 step via C
    bytecode:
      value: 0x2e
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  rrb:
    # Rotate right byte at abs addr 1 step via C
    bytecode:
      value: 0x2f
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  not:
    # Bitwise NOT A: A = ~A
    bytecode:
      value: 0x30
      size: 8
  noz:
    # Bitwise NOT Z: *Z = ~(*Z)
    bytecode:
      value: 0x31
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  nob:
    # Bitwise NOT byte: *addr = ~(*addr)
    bytecode:
      value: 0x32
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  nov:
    # Bitwise NOT zero-page word: *V = ~(*V)
    bytecode:
      value: 0x33
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  now:
    # Bitwise NOT word at abs address
    bytecode:
      value: 0x34
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  noq:
    # Bitwise NOT zero-page long
    bytecode:
      value: 0x35
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  nol:
    # Bitwise NOT long at abs address
    bytecode:
      value: 0x36
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  neg:
    # Negate A: A = -A
    bytecode:
      value: 0x37
      size: 8
  nez:
    # Negate zero-page byte: *Z = -(*Z)
    bytecode:
      value: 0x38
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  neb:
    # Negate byte at abs address: *addr = -(*addr)
    bytecode:
      value: 0x39
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  nev:
    # Negate zero-page word: *V = -(*V)
    bytecode:
      value: 0x3a
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  new:
    # Negate word at abs address
    bytecode:
      value: 0x3b
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  neq:
    # Negate zero-page long
    bytecode:
      value: 0x3c
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  nel:
    # Negate long at abs address
    bytecode:
      value: 0x3d
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  ani:
    # Bitwise AND immediate: A = A & imm
    bytecode:
      value: 0x3e
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - immediate_8bit
  anz:
    # Bitwise AND zero-page byte: A = A & *Z
    bytecode:
      value: 0x3f
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  anb:
    # Bitwise AND byte at abs address: A = A & *addr
    bytecode:
      value: 0x40
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  ant:
    # Bitwise AND byte at rel zero-page address: A = A & *(*Z)
    bytecode:
      value: 0x41
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_zero_page
  anr:
    # Bitwise AND byte at rel address: A = A & *(*addr)
    bytecode:
      value: 0x42
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  an.z:
    # Bitwise AND A to zero-page byte: *Z = *Z & A
    bytecode:
      value: 0x43
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  an.b:
    # Bitwise AND A to byte at abs address: *addr = *addr & A
    bytecode:
      value: 0x44
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  ori:
    # Bitwise OR immediate: A = A | imm
    bytecode:
      value: 0x45
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - immediate_8bit
  orz:
    # Bitwise OR zero-page byte: A = A | *Z
    bytecode:
      value: 0x46
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  orb:
    # Bitwise OR byte at abs address: A = A | *addr
    bytecode:
      value: 0x47
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  ort:
    # Bitwise OR byte at rel zero-page address: A = A | *(*Z)
    bytecode:
      value: 0x48
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_zero_page
  orr:
    # Bitwise OR byte at rel address: A = A | *(*addr)
    bytecode:
      value: 0x49
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  or.z:
    # Bitwise OR A to zero-page byte: *Z = *Z | A
    bytecode:
      value: 0x4a
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  or.b:
    # Bitwise OR A to byte at abs address: *addr = *addr | A
    bytecode:
      value: 0x4b
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  xri:
    # Bitwise XOR immediate: A = A ^ imm
    bytecode:
      value: 0x4c
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - immediate_8bit
  xrz:
    # Bitwise XOR zero-page byte: A = A ^ *Z
    bytecode:
      value: 0x4d
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  xrb:
    # Bitwise XOR byte at abs address: A = A ^ *addr
    bytecode:
      value: 0x4e
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  xrt:
    # Bitwise XOR byte at rel zero-page address: A = A ^ *(*Z)
    bytecode:
      value: 0x4f
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_zero_page
  xrr:
    # Bitwise XOR byte at rel address: A = A ^ *(*addr)
    bytecode:
      value: 0x50
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  xr.z:
    # Bitwise XOR A to zero-page byte: *Z = *Z ^ A
    bytecode:
      value: 0x51
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  xr.b:
    # Bitwise XOR A to byte at abs address: *addr = *addr ^ A
    bytecode:
      value: 0x52
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  fne:
    # Fast branch on non-zero
    bytecode:
      value: 0x53
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  feq:
    # Fast branch on equal
    bytecode:
      value: 0x54
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  fcc:
    # Fast branch on carry clear
    bytecode:
      value: 0x55
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  fcs:
    # Fast branch on carry set
    bytecode:
      value: 0x56
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  fpl:
    # Fast branch on plus
    bytecode:
      value: 0x57
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  fmi:
    # Fast branch on minus
    bytecode:
      value: 0x58
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  fgt:
    # Fast branch on greater
    bytecode:
      value: 0x59
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  fle:
    # Fast branch on less or equal
    bytecode:
      value: 0x5a
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  fpa:
    # Fast jump to lsb address
    bytecode:
      value: 0x5b
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address_lsb
  bne:
    # Branch on non-zero
    bytecode:
      value: 0x5c
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  beq:
    # Branch on zero
    bytecode:
      value: 0x5d
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  bcc:
    # Branch on carry clear
    bytecode:
      value: 0x5e
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  bcs:
    # Branch on carry set
    bytecode:
      value: 0x5f
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  bpl:
    # Branch on plus
    bytecode:
      value: 0x60
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  bmi:
    # Branch on minus
    bytecode:
      value: 0x61
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  bgt:
    # Branch on greater
    bytecode:
      value: 0x62
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  ble:
    # Branch on less or equal
    bytecode:
      value: 0x63
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  jpa:
    # Jump to address
    bytecode:
      value: 0x64
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  jpr:
    # Jump to relative address
    bytecode:
      value: 0x65
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  jar:
    # Jump A-indexed to rel address: PC = *(addr + A)
    bytecode:
      value: 0x66
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  jps:
    # Jump to subroutine
    bytecode:
      value: 0x67
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  jas:
    # Jump to subroutine conserving A
    bytecode:
      value: 0x68
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - address
  rts:
    # Return from subroutine
    bytecode:
      value: 0x69
      size: 8
  phs:
    # Push A to stack
    bytecode:
      value: 0x6a
      size: 8
  pls:
    # Pull A from stack
    bytecode:
      value: 0x6b
      size: 8
  lds:
    # Load from stack: A = *(0xff00 + SP + off)
    bytecode:
      value: 0x6c
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - immediate_8bit
  sts:
    # Store to stack: *(0xff00 + SP + off) = A
    bytecode:
      value: 0x6d
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - immediate_8bit
  rdb:
    # Read FLASH data from abs 3-byte address
    bytecode:
      value: 0x6e
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_16bit   # flash address
          - immediate_8bit    # bank
  rdr:
    # Read FLASH data from rel 3-byte address
    bytecode:
      value: 0x6f
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  rap:
    # Read FLASH data from A-indexed 3-byte address  A = *(pg<<8 + A)
    bytecode:
      value: 0x70
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_8bit  # page
          - immediate_8bit  # bank
  rzp:
    # Read Z-indexed FLASH data: A = *(pg<<8 + *Z)
    bytecode:
      value: 0x71
      size: 8
    operands:
      count: 3
      operand_sets:
        list:
          - zero_page
          - immediate_8bit  # page
          - immediate_8bit  # bank
  wdb:
    # Write FLASH data to abs 3-byte address
    bytecode:
      value: 0x72
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_16bit   # flash address
          - immediate_8bit    # bank
  wdr:
    # Write FLASH data to rel 3-byte address
    bytecode:
      value: 0x73
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  ldi:
    # Load immediate value to A: A = imm
    bytecode:
      value: 0x74
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - immediate_8bit
  ldz:
    # Load zero-page byte to A: A = *Z
    bytecode:
      value: 0x75
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  ldb:
    # Load byte at abs address to A: A = *addr
    bytecode:
      value: 0x76
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  ldt:
    # Load byte at rel zero-page address to A: A = *(*Z)
    bytecode:
      value: 0x77
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_zero_page
  ldr:
    # Load byte at rel address to A: A = *(*addr)
    bytecode:
      value: 0x78
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  lap:
    # Load A-indexed byte to A: A = *(pg<<8 + A)
    bytecode:
      value: 0x79
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - immediate_8bit  # page
  lab:
    # Load A A-indexed from addr: A = *(addr + A)
    bytecode:
      value: 0x7a
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  lzp:
    # Load Z-indexed byte to A: A = *(pg<<8 + *Z)
    bytecode:
      value: 0x7b
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - zero_page
          - immediate_8bit  # page
  lzb:
    # Load Z-indexed byte from addr: A = *(addr + *Z)
    bytecode:
      value: 0x7c
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - zero_page
          - absolute_address
  stz:
    # Store A to zero-page byte: *Z = A
    bytecode:
      value: 0x7d
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  stb:
    # Store A to byte at abs address: *addr = A
    bytecode:
      value: 0x7e
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  stt:
    # Store A to byte at rel zero-page address: *(*Z) = A
    bytecode:
      value: 0x7f
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_zero_page
  str:
    # Store A to byte at rel address: *(*addr) = A
    bytecode:
      value: 0x80
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - relative_address
  szp:
    # Store Z-indexed A: *(pg<<8 + *Z) = A
    bytecode:
      value: 0x81
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - zero_page
          - immediate_8bit  # page
  miz:
    # Move immediate to zero-page byte: *Z = imm
    bytecode:
      value: 0x82
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_8bit
          - zero_page
  mib:
    # Move immediate to byte at abs address: *addr = imm
    bytecode:
      value: 0x83
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_8bit
          - absolute_address
  mit:
    # Move immediate to byte at rel zero-page address: *(*Z) = imm
    bytecode:
      value: 0x84
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_8bit
          - relative_zero_page
  mir:
    # Move immediate to byte at rel address: *(*addr) = imm
    bytecode:
      value: 0x85
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_8bit
          - relative_address
  miv:
    # Move immediate word to zero-page word: *V = imm
    bytecode:
      value: 0x86
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_16bit
          - zero_page
  miw:
    # Move immediate word to word at abs address: *addr = imm
    bytecode:
      value: 0x87
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - immediate_16bit
          - absolute_address
  mzz:
    # Move zero-page byte to zero-page byte: *Z2 = *Z1
    bytecode:
      value: 0x88
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - zero_page
          - zero_page
  mzb:
    # Move zero-page byte to byte at abs address: *addr = *Z
    bytecode:
      value: 0x89
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - zero_page
          - absolute_address
  mbz:
    # Move byte at abs address to zero-page byte: *Z = *addr
    bytecode:
      value: 0x8a
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - absolute_address
          - zero_page
  mbb:
    # Move byte at abs address to byte at abs address: *addr2 = *addr1
    bytecode:
      value: 0x8b
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - absolute_address
          - absolute_address
  mvv:
    # Move zero-page word to zero-page word: *V2 = *V1
    bytecode:
      value: 0x8c
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - zero_page
          - zero_page
  mwv:
    # Move word at abs address to zero-page word: *V = *addr
    bytecode:
      value: 0x8d
      size: 8
    operands:
      count: 2
      operand_sets:
        list:
          - absolute_address
          - zero_page
  clz:
    # Clear zero-page byte: *Z = 0
    bytecode:
      value: 0x8e
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  clb:
    # Clear byte at abs address: *addr = 0
    bytecode:
      value: 0x8f
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  clv:
    # Clear zero-page word: *V = 0
    bytecode:
      value: 0x90
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  clw:
    # Clear word at abs address: *addr = 0
    bytecode:
      value: 0x91
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
  cql:
    # Clear zero-page long: *Q = 0
    bytecode:
      value: 0x92
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - zero_page
  cll:
    # Clear long at abs address: *addr = 0
    bytecode:
      value: 0x93
      size: 8
    operands:
      count: 1
      operand_sets:
        list:
          - absolute_address
